// use std::{
//     collections::HashMap,
//     fs::File,
//     io::{BufReader, Read},
//     str::FromStr,
// };

// use crate::middleware::config::ConfigIface;
// use serde_json::Value;
// use web3::{
//     api::{Eth, Namespace},
//     contract::Contract,
//     ethabi::Contract as EthContract,
//     types::H160,
// };

// /// Struct for on-chain interactions with deployed contracts.
// /// A valid web3 account with signer must be passed into contract interaction functions.
// /// Solely intended for use by SemaphoreAccount in account.
// struct SemaphoreTransactions {
//     //HSS smart contract ABI.
//     hss_abi: HashMap<String, Value>,
//     //HSS smart contract address.
//     hss_adress: String,
//     //Web3 lib HSS contract object.
//     //// TODO: Check type!!
//     hss_contract: Contract<&HTTP>,
//     //RPC address used for smart contract interaction.
//     rpc: String,
// }

// impl SemaphoreTransactions {
//     pub fn new() -> Self {
//         let rpc = ConfigIface::get_config().rpc_url;

//         let hss_adress = ConfigIface::get_config().hss_address;

//         // Open config file and parse JSON.
//         let mut hss_abi_file = File::open("src/abi.json").expect(
//             "Could not open the config file. Please provide a abi.json in `src` directory.",
//         );
//         let mut hss_abi_str = String::new();
//         hss_abi_file
//             .read_to_string(&mut hss_abi_str)
//             .expect("Unable to read the data!");
//         let hss_abi: HashMap<String, Value> =
//             serde_json::from_str(&hss_abi_str).expect("JSON was not well-formatted!");

//         let hss_abi_reader = BufReader::new(hss_abi_file);
//         let hss_abi_contract =
//             EthContract::load(hss_abi_reader).expect("JSON was not well-formatted!");
//         let transport_url =
//             web3::transports::Http::new(&ConfigIface::get_config().rpc_url).unwrap();
//         let eth = Eth::new(&transport_url);
//         let hss_adress_h160 = H160::from_str(&ConfigIface::get_config().hss_address).unwrap();
//         let hss_contract = web3::contract::Contract::new(eth, hss_adress_h160, hss_abi_contract);

//         // let eth_cont =
//         //     web3::ethabi::Contract::load(hss_abi_reader).expect("JSON was not well-formatted!");

//         Self {
//             hss_abi,
//             hss_adress,
//             hss_contract,
//             rpc,
//         }
//     }
//     /// Adds subscriber and their uncompressed public key to the HSS contract storage.
//     fn add_sub_and_key(web3_account: String, uncompressed_pub_key: String) -> String {
//         let nonce = web3::contract::Options:
//     }
// }
